# 백준 특강

**코딩 테스트**

- 다양한 기업에서 코딩 테스트를 보고 있다.
- 알고리즘 문제 종류가 엄~청 많은데 그 중에 주로 파싱, 시뮬레이션, 브루트 포스, BFS, 다이나믹 프로그래밍이 문제에 나온다.
- 약 2-3시간 1-2문제를 푼다.
- 삼성 문제 수 2개, 합격 컷 1-2, 시간 3시간 / 하이닉스 문제 수 3개, 합격 컷 1, 시간 2시간 / 하이닉스 2차 문제 수 3, 합격 컷 1-2, 시간 2시간 / 카카오는 4개 중 3.5 1개 중 1개를 풀어야한다. 시간은 5시간
- 학생들의 많은 질문들 : 왜 하냐 이거, 돈 되냐, 재밌냐, 뭐가 좋냐
  - 코딩 테스트는  알고리즘 문제를 잘 푸는 사람을 뽑는 것이 목적이 아님. 그러면 왜일까요? 문제 해결 능력을 알아보기 위해서이다. ex) 쇼핑물 상품 추천 문제, 장바구니 물건의 합을 구하는 문제
  - 문제 난이도가 뭐 대회 수준은 아니다. 이 정도면 되겠다 정도의 수준
- 알고리즘 문제는 상대적으로 대부분의 개발보다 크기가 작다.
- 어떤 문제를 알고리즘 문제 스타일로 변형하는 경우가 많다.
- 문제를 모델링하고 해결하는 능력을 알아보기 위한 알고리즘 문제이다.- 



**CBT 방식과 Coding Interview**

- 코딩 테스트 방식

  - 온라인으로 보기 : 각자 알아서 컴퓨터로 문제를 품

  - 오프라인 시험 : 지정된 장소에 모여서, 컴퓨터로 문제를 품

    - 온라인 / 오프라인은 장소의 차이일 뿐 상관이 없다.

  - 손 코딩 : 필기 시험이랑 같다. 되게 귀찮다. 나도 귀찮고, 채점도 귀찮고

  - 코딩 인터뷰 : 불완전한 문제를 제시한다. 빠진 조건이 있다면 면접관과 얘기하면서 문제를 완성시켜 나가야 함. 외국계 기업에서 주로 한다. 빠르게 풀 필요도 없고, 잘 푸는거 보단 어떤 과정으로 푸는 지가 중요하다. 60분의 시간안에 40분만에 풀어버리면 20분 동안 계속 질문할건데 그냥 정답 알더라도 천천히 진행하도록하자.

  - 입/출력을 받고 전체 코드를 작성하는 방식인지, 함수를 구현하는 방식인지는 난이도와 상관이 없음

  - 알고리즘 문제는 주로 제목, 문제 본문, 입력 형식 설명, 출력 형식 설명, 예제 입/출력, 힌트, 시간 제한, 메모리 제한으로 이루어져 있음, 가장 먼저 읽으면 좋은 것은 N제한 (입력의 크기)

    - N <10 / N <100 / N<100만의 문제를 풀 각각의 A B C 방법 중 C로 푸는것이 제일 좋음. 왜냐면 C로 풀면 나머지 다 풀 수 있으니까.
    - 문제를 만들 때도 제한을 먼저 두고 문제를 만든다고 한다. 그만큼 제한이 중요하다.

    - 보통 알고리즘 문제 10문제 정도 풀면 꽤 풀었다. 라고 합디다.

  - 가끔 힌트로 어떻게 예제의 정답이 나오는지 설명하는 경우가 있는데, 이 때 설명하기 위한 방법은 문제의 풀이 방법이 높은 확률로 아님

    - 힌트를 이용해서 왜 틀렸냐고 물어보는 경우도 있다.

  - 시간 제한과 메모리 제한, 무엇이 더 중요할까?

    - 시간 제한이 훨씬 중요하다. 시간은 돈으로 살 수 없고, 메모리는 돈으로 살 수 있으니
    - 게임 하는 데 키 눌렀는데 3초 뒤에 반응오면 너무 열받음.
    - 옛날 알고리즘 문제 같은 경우엔 메모리가 더 중요했다고 한다. 그러한 문제는 대단히 메모리를 효율적으로 사용하려고 했다. 백준 알고리즘 사이트에 있다고 한다.
    - 메모리 초과가 나는 코드는 시간 초과도 날 확률이 매우 높다. 



**코딩 테스트 준비**

- 게임을 잘하고 싶다. 어떻게 해야 할까?
  - 많이 해야 한다.
  - 무작정 많이 해선 안된다.
  - 코딩도 그렇다. (꽃은 이쁘다. 너도 그렇다.)
- 어떤 알고리즘의 원리와 증명을 이해하는 것이 중요하다.
- 원리와 증명은 매우 중요하기는 하나, 코딩 테스트에서는 응용하는 것을 더 중요하게 생각한다. (원리 증명하기엔 시간이 오래 걸리니)
- 어떤 문제를 보고 도움 없이 스스로 방법을 떠올려야 할 필요는 없다.
  - 예를 들어서 미분, 적분을 스스로 떠올리는 것을 요구하지 않는다.
- 이 문제를 어떻게 푸는지 모르겠으니 스스로 풀어내는 것이 나쁜 생각은 아니지만, 할 일도 많고, 인생은 짧으니, 시간은 없구 약 2~3시간 고민해보고 답을 찾아보자.
  - 검색을 하는 것도 매우 중요하고, 답을 찾고 이해하는 능력도 중요하다.
    - 예를 들어서 백준의 1234번 문제를 모르겠으면, 구글에 1234번 백준이라 치면 많은 블로그에서 답변이 나온다.
  - 나는 이해는 못하겠으니, 문제의 답을 외워야겠다.
    - 개소리입니다. (왈왈)
- 기출 문제를 열심히 풀어보고, 기출 문제와 비슷한 내용이 나오는 문제를 풀어봐야한다.
  - 비슷한 내용이 나오는 문제는 별로 안 중요하고, 비슷한 알고리즘을 사용하는 문제를 풀어보는 것이 좋다.
- 참고로 삼성 코딩 테스트 풀 수 있으면, 나머지 다 풀 수 있다. (하이닉스 빼구, 카카오 빼구)
- 나는 BFS도 알고, 브루트 포스도 알고, 다이나믹 프로그래밍도 안다. 그런데 문제는 못 풀겠다.
  - 그러니까 이 문제를 푸는 알고리즘이 무엇인지는 어떻게 알아내는 것일까?
    - 없음. 각각의 알고리즘의 특징을 알고, 왜 그 알고리즘으로 다른 문제를 풀 수 있었는지를 위주로 기억해서 문제에 적용해봐야 한다.
    - 그냥 경험이 중요하다.
- SW Expert Academy, 백준 알고리즘에서 문제를 '많이' 푸는것이 중요하다.
- 알고리즘 강의를 듣는 건 자유지만, 검색으로도 충분히 공부가 가능하다고 한다.



**코딩테스트의 변천사**

- 삼성이 시작하니까 여러 기업이 코딩 테스트를 시작하기 시작했다. 기업별로 준비하는 것보다 크게 보고 알고리즘 문제를 해결하다 보면 된다.



**시간복잡도**

- 사전에 입력의 크기가 중요하다고 했는데, 입력의 크기에 따라서 시간이 얼마나 걸리는 지를 아는 것이 시간 복잡도라고 한다.
- 보통 N은 1<=N<=100,000 여기서 100,000 값이 1억으로 바뀌면 **1억은 대략 출력까지 1초가 걸린다.** 만약 문제가 N^2이고 1초만에 출력이 나와야한다면 문제를 못푼다. 왜냐면 N^2이 100억이 되니까 100초가 소비되니까.
- 그니까 코딩하기 전에 시간 복잡도를 먼저 생각하면 좋다



**공간복잡도**

- 시간 복잡도가 더 중요하지만 뭐 배열이 부족하거나 하면 그냥 배열을 늘리면 해결하면 된다.



**맞왜틀**

- 맞았는데 왜 틀려요?
- 컴터에서는 되는데 제출하면 틀렸데, 그럼 왜 틀렸지?
- 이걸 극복하기 위한 방법
  1. 예제말고 다른 것을 넣어봐야한다.
     - 다른 거 넣었을 때 답인지는 모르지만, 다른 사람과 비교를 해보던가. 그 문제를 다른 방법으로 풀어보자
  2. 예제의 순서를 바꾼다.
  3. 최소값, 최대값을 넣어보자
  4. 극단적인 케이스 (전부 음수일 때, 전부 0일 때)
  5. 정말로 방법이 틀린 경우 (너무 붙잡지 말고, 검색을 하거나 넘어가도록 하자)



**Brute Force, BFS, DP**

- 이 3가지는 모두 공통적인 특징이 있는데 그것이 상태(State)이다.

- Brute Force는 재귀함수로 푼다. (function(a,b,c) 이런 것들)
- BFS는 그래프 알고리즘이라서 정점의 정보가 필요하다. (좌표, 장소 이런 것들)
- DP는 정화식이 필요하다. (배열 이런 것들)
- 결국 저것들이 전부 상태이다.



**상태**

- 집 -> 강남역 -> 역삼역 -> 건물로 출근을 했는데 각각의 이동 방법으로는 택시, 버스가 있다. 각각의 이동에서는 택시는 5분 버스는 20분이 걸린다. 참고로 집에서 강남역까지 택시로 15분이고 버스로는 30분이 걸린다.
  - 만약 제일 빨리 가는 시간이 무엇이냐면 25분이다.
- 만약 Brute Force 문제면 집 강남역 역삼역 건물이 함수의 인자가 된다. BFS는 집 강남역 역삼역 건물이 정점이 될 것이다.
- 만약 강남역에서 출발을 한다고하면 집이 있든 말든 상관없다. 어차피 강남역에서 역삼역으로 가는 것이 집이 있든 말든 상관 없으니까.
- 이제 조건을 추가해보자.
  - 택시는 1번만 탈 수 있다.
  - 이렇게 된다면 아까 상관이 없었던 것이 상관이 있게된다. 왜냐면 택시를 탄 횟 수 때문에, 이미 택시를 타고 왔을 수도 있고 아니면 버스를 타고 강남역으로 도착했을 수도 있기 때문에
  - 즉, 함수의 인자가 늘어난거고, 2차원 다이나믹이 된것이고, 정점이면 정점의 정보가 하나 더 추가된다.



**그 외 기타**

- 참고로 파싱 시뮬레이션 알고리즘은 쉽고, 브루트 포스 BFS는 중간, 다이나믹 프로그래밍은 어려운 수준

- 브루트 포스는 재귀함수로 정의한다.

  - 어떤 방법이 다 해보는 것을 브루트 포스라고 한다. 예를 들어서 사물함 비밀번호가 있는데 자물쇠 비밀번호가 숫자 3자리면 1000번만에 풀 수 있겠지? 즉, 주어진 조건 내에서 모든 것을 시도하는 것.

  - 그렇기 때문에 시간에 민감하다. 만약 비밀번호 숫자가 12자리라면? 10^13초 걸림 하나에 1초 걸린다면 30만년 걸림.(사람이 하면) 근데 컴퓨터가 해도 오래 걸릴 시간 같음. 그래서 다른 방법을 찾아야한다.

  - N! / 2^N의 유형을 주로 브루트 포스로 푼다.

    - 예를 들어서 사과 바나나 포도 깔라만시 망고의 순서 정할 때
    - 무엇을 한다 / 안한다. 2가지 선택이 N개 있을 때

  - 예제

    ```PYTHON
    1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열을 모두 구하는 문제
    1<=M<=N<=8
    재귀함수로 푸는 방법은
    만약 N=4고 M=3이면
    _ _ _
    index(0)에는 1~4까지 모두 채울 수 있다.
    index(1)에는 index(0)을 제외한 모두를 넣을 수 있다.
    index(2)에는 index(0),index(1)을 제외한 모두를 넣을 수 있다.
    
    ####################################################
    1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열을 모두 구하는 문제(오름차순)
    1<=M<=N<=8
    _ _ _
    만약 첫 자리에서 2가 오면 둘,셋째 자리는 3 4만 됨
    #start를 사용하여 문제를 풀었는데 위에 문제랑 차이 있는건 이 start 밖에 없다.
    
    ################################################################################
    #이제 반대로 풀어보자
    1~N개 중에서 M개를 고르고 오름차순이다
    1, 2, 3, .... N 개가(오름차순으로) 있다고 했을 때 1이 들어갈지말지 2가 들어갈지말지를 정하는거처럼 모든 수 중에서 들어가겠다고 하는 수들만 뽑아낼 수도 있다. (2^N개이다).
    #이렇게 풀면 시간이 엄청 줄어든다. 상당히 많이 쓰이는 방법
    
    #######################################################
    1부터 N개 중 M개를 골라서 수열을 구하는 문제(중복 선택 가능)
    1<=M<=N<=8
    #앞에 문제와 딱 하나의 차이다. 어떤 수를 사용했는지 유지할 필요가 없다. 그래서 그 코딩한 것에서 중복 처리 한 줄만 없애주면 해결된다. 간-단.
    ```




**질문**

- 코딩 테스트 할 때 무슨 언어 써야하나요?
  - 지 잘하는거 하면 된다.
- 어플 이름 뭔가요
  - My Script Calculator
- 문제 채점 어떻게 되나요
  - 어디서든 다 동일한데, 입력파일과 출력파일을 만들어 주는데 그 제출한 소스코드에 2개를 넣어보고 비교하여 같으면 정답이다.
  - 어떤 문제에서 1<=N<=30이 범위가 작은데 굳이 어렵게 하는거 보다 if문으로 해결해서 답이 맞아도 가능하다. 코드 열어보는건 귀찮잖아 채점하는 사람두.
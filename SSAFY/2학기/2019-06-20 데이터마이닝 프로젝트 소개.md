# 2019-06-20 데이터마이닝 프로젝트 소개

## 빅데이터 사용 사례

- 미국 LA 경찰
  - LA에서 향후 12시간 내 범죄 발생 가능성이 높은 지역을 예측하고 컴퓨터의 지시대로 경찰이 순찰
- Southwest라는 항공회사는 비행기의 오작동이나 안전 문제를 나타내는 패턴을 알아내기 위해 비행기의 센서 데이터를 분석
- Aurora라는 회사는 의료 데이터를 수집해서 어떤 병이 왜 일어나는지 알 수 없었지만, 분석을 통해 해결했다.
- 코카콜라도 주스가 일년 내내 일관된 맛을 유지할 수 있도록 데이터를 분석

## Moore의 법칙의 전성시대가 막을 내리고 있는 중

- 2년마다 집적회로, 반도체의 향상 속도가 20배가 뛰고 있다는 뜻이다.
- 그 한계가 왔다.
- 빅 데이터를 처리는 한 대의 컴퓨터의 능력으로 처리가 어렵다
  - 그렇기에 수 천대의 컴퓨터를 묶어서 처리 해야 함
  - 맵리듀스 프레임 워크가 하는 것이 바로 이것이다.
  - 맵 리듀스는 대규모로 컴퓨팅을 잘 분산 병렬로 처리할 수 있도록 해준 첫 번째 프로그래밍 모델입니다.
- 구글이 맵리듀스를 사용했지만, 오픈소스 커뮤니티에서 구현한 하둡을 받아서 사용할 수 있다.
  - 유저가 map, reduce 그리고 main 함수들만 프로그래밍 해주면 됩니다.
  - map이 컴퓨터에 데이터를 분산시키는 함수
  - reduce가 분산된 데이터를 처리하고 모아주는 함수
- 하둡은 Apache 프로젝트의 MapReduce의 오픈소스이다.
  - 빅데이터를 여러 대의 컴퓨터에 분산해서 저장
  - 각각의 파일은 블럭의 시퀀스로 저장
  - 파일의 각각의 블록은 여러 개의 컴퓨터에 복사해서 저장하여 한 개의 블록이 망가져도 나머지 블록은 망가지지 않는다.
- 데이터 마이닝 기술
  - 데이터 자체는 듣거나 말할 수 없기에 숨겨진 의미를  파악하기 위해 컴퓨터 등의 전문 분석 도구가 필요하다

## 프로젝트 설명

- NETFLIX, YouTube처럼 추천 시스템을 만들어 줄 것이다.
- 영화 평점 데이터를 이용해서 유사한 유저들 또는 유사한 영화들을 보여주며 여러가지 클러스터링 알고리즘들을 이용해서 분석
- Djnago를 이용하여 어플리케이션의 UI를 구현할 것이다
- Python 언어의 numpy와 scipy 라이브러리를 사용해서 행렬을 표현하고 연산하는 기본적인 함수들을 이해하고 효율적으로 사용하는 것을 배울 것이다.
- 추천에 이용되는 Collaborative Filtering 주요 알고리즘 이해
  - KNN 알고리즘
  - Matrix factorization 알고리즘
  - Matrix factorization + PLSI 알고리즘
- Probabilistic Modeling 기술을 습득
- Python의 sparse matrix format을 사용할 것이다.
- 개발 환경
  - python 사용
  - virtualerwrapper
  - Django
- UI를 예쁘게 만들고, 포스터나 예고편, 동영상, 리뷰를 보여주던지 합시다.
- GPU를 잘 이용하도록 Python 코드 구현
- 기계학습 툴들을 이용해서 PLSI 대신에 딥 러닝 알고리즘을 접목

## 연구실 선배가 만든 기능

- 어떤 애가 트위터에서 팔로우 할 만한 사람을 추천하는 것을 만들었다.

## Clustering(군집화)란?

- 비슷한 애들끼리 묶는 것을 Clustering이라고 한다. 그룹이나 cluseter랑 같은 말입니다.
  - 그러면 새로운 애들이 들어오더라도 비슷한 부류에 집어넣으면 된다.
  - 클러스터를 하는 경우의 수는 엄청나게 많은데, 그래서 오래 걸리지 않는 클러스터링 알고리즘이 필요하다.
- 어떤 클러스트링이 좋은지 어떻게 평가하는지 봅시다

## K-Means Clustering

#### 기본 개념

1. 각각의 점들을 랜덤하게 클러스터에 할당
2. 각각의 중앙값 구하기
3. 각 점과 가장 가까운 중앙값의 클러스터로 그 점을 옮기기
4. 클러스터의 중앙값을 새로 구함
5. 또 다시 3 -> 4
6. 클러스터가 더이상 변하지 않을 때 종료

즉, 각 클러스터 중앙 값을 계속해서 찾아가는것이 목표이고 중앙 값에 도착하면 종료



#### 단점(drawbacks)

- 클러스터별 점들의 개수가 불균형
- 거리를 이용해서 함 -> 구형의 결과가 나옴 -> but 구형이 아닌 형태로 cluster가 존재한다면?
- sensitive to outliers -> outlier에 의해 bias가 생기게 됨
- K-Medoids : 중심과 가장 가까운 점을 기준으로 삼는 방법
- 구형이 아니면 제대로 작동 못함

## EM Clustering

- K-means보다 좋은 알고리즘

## PLSI 확률 모델

- 추천 시스템에 넣는 모델, 있고 없고가 굉장히 차이가 크다.
- 줄거리에 나오는 단어들을 이용해서 그 단어가 많이 나오는 장르끼리 묶어서 추천해주는 확률 모델
- 즉, 주제에 맞는 단어를 골라서 추천을 하는 것입니다.
- 예를 들어 엠마왓슨이 쓴 글 중에 Excited, UK, Harry Potter 등 이런 단어들을 묶어서 단어가 어떤 토픽에 나왔는지 곱하기 단어가 뽑힐 확률을 곱해서 모델링을 한 것이 PLSI 입니다.
- 얘는 순서가 고려 안된 것이 특징입니다.
- 비유하자면 주머니 예제이다
  - 주머니가 토픽이고, 공이 단어이면 공을 꺼내서 문장을 만드는데, 문장이 만들어지는 방법 중 하나가 토픽 주머니 중에서 공을 꺼내서 만들어지는데 그 확률이 있을 것이다.
  - 이런 식으로 문장을 썼다고 가정하는 것이 PLSI 이다. 그렇게 만들어진 문장 중에서 제일 적합한 문장을 구하는 확률 모델링 구하는 것이 목적이다.
- 실제로 사람이 주제를 고르고 단어를 고르고 글을 쓰진 않지만, 그 써내려간 글을 수학적으로 분석할 수 었지만, 어떻게 그나마 일리있게 분석을 할 수 있을까를 PLSI 확률 모델을 만든 것이다.
- 즉, 주제마다 단어들을 클러스터링을 한 것이다.
- 처음에 소개한 TWITOBI가 이 것을 이용했다.
  - 자기만의 Topic을 이용한 것이 아니라 Follower들의 Topic도 이용해서 구현한 서비스이다.
  - 자기 주제는 a, 남의 주제는 1 - a의 확률로 계산한다.
- 우리는 줄거리에서 알고리즘을 통해 토픽을 골라내서 추상적인 토픽을 만들어낸다. 즉 각각의 토픽마다 확률을 구한다.

## Matrix Factorization

- 추천 시스템에서 사용하는 시스템 중에 Content based filtering method가 있는데 각 item간의 similarity를 이용해서 추천함
- Collaborative filtering method는 각각의 유저는 비슷한 다른 유저와 동일하게 행동한다는 가정
  - User가 직접 점수를 매긴 item들에 대한 rating을 이용해서 추천
  - preference pattern을 이용함
  - 얘도 두 가지로 나눌 수 있다.
    - Memory based method
      - 과거의 rating에 base에서 prediction을 함
      - db에 있는 matrix의 곱가지고 사람들에게 product를 추천할지 안할지를 분석
    - Model based method
      - 유저 데이터 베이스를 이용해서 prediction을 위한 model을 생성
      - 과거의 rating에 base 해서 model을 만들고 그 모델에 의해서 unseen item에 대한 rating을 함
- Matrix Factorization은 무엇일까?
  - user 아이템과 items 사이에 related 된 행렬이 있다. 그리고 유저 벡터와 아이템 벡터를 내적한 값이 related된 행렬과 유사하다는 것을 말한다.
  - 그 벡터를 어떻게 구하느냐면 얘도 역시 최적화로 풉니다.
    - 실제값과 차이가 최소가 되도록 계산을 합니다.
  - 기존의 방법과 향상된 방법 2가지가 있습니다.
    - 향상된 방법은 PLSI 모델을 이용하여 영화에 따른 주제 확률분포를 이용하여 행렬 V를 구하는데 이용하여 더 많은 정보를 사용해서 좀 더 나은 행렬 U와 V를 찾아낸다.
    - 우리 프로젝트에서는 PLSI를 할 것이다.

## 프로젝트 개요

- 클러스터링 알고리즘
  - K-Means Clustering
  - EM Clustering
  - 위 두가지를 구현해서 가장 유사한 유저 추천
- Collaborative Filtering 주요 알고리즘
  - K-nearst neighbor (KNN)
  - Matrix factorization 알고리즘
  - PLSI 알고리즘

## KNN 알고리즘

- KNN은 모든 유저들 간의 데이터를 이용해서 좋아할만한 영화를 추천하는 알고리즘이다. 최근접 알고리즘이라고 한다. 특정공간내에서 제일 근접한 k개의 요소를 찾아, 더 많이 일치하는 것으로 분류하는 알고리즘이다.

- KNN은 neighbor를 이용해서 하기 때문에 데이터가 작으면 유사한 유저를 찾을 수 없는 경우가 있어서 별로 좋진 않다. 

```python
R_u1_i1

u1 4 3 0 2 1
u2 0 3 4 0 5
u3 1 0 2 0 1

# u1 u2가 얼마나 친근(Similarity)한지를 봅시다. 내적을 하면 됩니다
S_u1_u2 = 14 / sqrt(30(u1의 크기)*40(u2의 크기))
S_u1_u3 = 5 / sqrt(30*6)

뭐라하는지 모르겠다.
```

우리 프로젝트에선 KNN을 구현하는 것이 있다.
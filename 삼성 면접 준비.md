# 삼성 면접 준비

## S 직군이란?

- S/W 지식을 바탕으로 반도체가 활용된  Solution 제품을 연구개발 하는 직무

### Role

- Firmware, Middleware, System S/W, Application S/W 개발

  - 제품(SSD, DRAM Module, CPU, GPU, Multimedia 등)의 요구사항에 부합하는 S/W 개발
  - Firmware, S/W 제품적용 및 평가, 제품 성능 최적화
  - Protocol, Device Driver, Linux, Windows S/W 개발
  - S/W Platform 개발

  > **펌웨어란?**

  - 전자기기의 제어 및 구동을 맡는 운영 체제의 일종. ROM에 기록. 
  - 특정 하드웨어 장치에 포함된 소프트웨어 (리모컨이 펌웨어로 동작하는 기기의 하나)

  > **미들웨어란?**

  - 운영 체제와 해당 운영 체제에서 실행되는 응용 프로그램 사이에 존재하는 소프트웨어
  - 운영 체제가 커맨드센터, 응용 프로그램이 미네랄, 미들웨어는 scv
  - 두 관계를 이어주는 역할이라 배관이라고도 함

  > **시스템 S/W란?**

  - 응용 프로그램과 하드웨어 장치 사이에 존재하는 소프트웨어를 명하는 용어
  - 보통 운영체제를 중심으로 개발도구, 각종 라이브러리나 미들웨어등이 모두 이에 포함된다.
  - 목표는 CPU, 메모리, 네트워크, 스토리지 등 다양한 하드웨어 장치에 대한 여러 레벨의 추상화를 응용프로그램에게 제공하면서 손쉬운 개발과 실행을 지원한다.
  - 시스템 소프트웨어는 사용자의 문제를 직접 해결하는 응용 소프트웨어와는 반대이다.

  > **SSD란?**

  - 반도체를 이용하여 정보를 저장하는 장치(보통 하드디스크라 부르는데 구조적으로 달라서 맞는 말은 아니고, 단 기억 장치로서 동일하긴 함)
  - HDD는 자기 디스크로 물리적으로 작동 되지만, SSD는 전자식이라서 빠름

- Automotive, 인공지능, IoT, Cloud, 보안 S/W 개발

  - BSP, Machine/Deep Learning, 음성/자연어처리, Cloud Platform, Computer vision 등 개발
  - RTOS 기반 Kernel, Network Stack 등 System 개발 및 NB-IoT 용 Telephoney, Protocol Framework 개발
  - 암호화, Embedded Systemm 보안, 통신/네트워크 보안, 보안 평가, 리버스 엔지니어링 등
  - 전장향 S/W Platform 개발

  > **BSP 란?**

  - 임베디드 시스템에서 BSP는 특별한 지원 코드로 실시간 운영체제에 적합한 상태에 동작되도록 한다.
  - 보드(하드웨어)를 동작시키기 위해 필요한 소프트웨어 묶음(임베디드)

  > **Kernel 이란?**

  - 컴퓨터의 운영 체제의 핵심이 되는 컴퓨터 프로그램의 하나로, 시스템의 모든 것을 완전히 통제한다.
  - 보통 운영체제가 이것을 의미한다. 하드웨어 자원을 관리하고 소프트웨어가 실행될 환경을 제공하는 소프트웨어이다.
  - 커널은 운영 체제의 핵심이라 커널의 역할 역시 운영 체제의 핵심 역할이다.

  > **RTOS 이란?**

  - 실시간 운영 체제(Real Time Operating System)는 실시간 응용 프로그램을 위해 개발된 운영 체제이다.

    > **OS 란?**

    - 운영체제는 하드웨어를 관리하고, 응용 프로그램을 동작시키기 위해 하드웨어 구성요소를 할당하는 역할을 한다. 즉 사용자가 프로그램을 실행할 때, 운영 체제를 통해 Hardware와 소통한다.

  > **리버스 엔지니어링(역공학) 이란?**

  - 기술 원리를 기술을 분해하면서 발견하는 과정

  >**임베디드 시스템이란?**

  - 내장형 시스템이라고도 하는 임베디드 시스템은 기계나 제어가 필요한 시스템에 대해, 제어를 위한 특정 기능을 수행하는 컴퓨터 시스템으로 장치 내에 존재하는 전자 시스템

  - 쉽게 말하면 전화기, 냉장고, 텔레비전 등은 모두 각자의 기능을 수행하기 위한 마이크로 컨트롤러를 가지고 있는데, 이것들이 프로그래밍이 가능하면 특수한 목적을 수행하기 위한 컴퓨터 이므로 임베디드 시스템이라 할 수 있다. (게임기도 넓은 관점에서 '게임'이라는 단일화된 소프트웨어를 대상으로 만들어진 임베디드 시스템이라 할 수 있다)

  - 임베디드 시스템의 하드웨어는 성능이 열악해서 가장 압축된 코드로 최고의 효율을 내야한다. IT 업계 중 가장 효율적인 코딩을 요구한다.

    > **임베디드 프로그래머의 업무**

    - 대기업은 BSP를 위주로 하는 경우가 많다. 워낙 사양이 낮기 때문에 외부 라이브러리를 들여올만한 공간이 거의 없다. 그래서 C 언어 위주로 직접 다 개발해서 쓴다.
    - C언어인데도 불구하고 객체지향적인 설계를 배워야 모듈이나 레이어 사이의 혼잡을 피할 수 있다.
    - C언어뿐만 아니라 어셈블리어를 배워야 장점을 잘 살린 C언어 사용이 가능하다.

  > **어셈블리어란?**

  - 프로그래밍 언어의 하나. 기계어에서 한 단계 위의 언어. 기계어와 함께 단 둘뿐인 로레벨 언어에 속함
  - 기계어는 컴퓨터만 좋지 인간 입장에선 불편한 언어임. 그래서 이 점을 보완하려고 어셈블리어가 생김
  - 사물인터넷에 쓰이는 초소형 기기에 어셈블리어가 많이 쓰인다. 이유는 C보다도 더 나아간 프로그램 최적화를 할 수 있는 유일한 언어이기 때문에 초소형 임베디드 시스템에 유용하다.
  - 근데 단지 기계어 대비 생산성이 높아졌지, 고급 언어에 비하면 생산성이 매우 떨어진다. 왜냐면 단어가 되게 축약되어 있어서 읽기에만 좀 편한거 뿐이지 이해하기 쉽게 서술하기 어렵다.
  - 예를 들어 CPU가 택배차이고 임무는 쌀배달이며 기계어 코드가 배송 계획이라고 할 때, 고급 언어로 배송 계획을 짠다면 택배차가 자전거인지 트럭인지에 따라 한 집씩 왕복하며서 배달할지 한 번 싣고 동네를 돌지를 컴파일러가 알아서 판단한다. 하지만 어셈블리어로 직접 코딩을 하면 택배차가 트럭으로 바뀌었는데도 여전히 트럭에 쌀 한가마니씩만 싣고 한 집씩 왕복하는 배송 계획을 실행한다. 왜냐면 고급 언어에서는 배송 계획을 짤 때 프로그래머가 ' 쌀을 쌀집에서 온 동네에 배송한다'라고 추상적으로 지시하지만 어셈블리어는 '쌀 하나를 싣는다, 100호에 간다. 100호에 도착해서 쌀을 내려놓는다. 쌀집으로 돌아온다. 쌀 하나를 싣는다. 101호를 간다...'라고 구체적으로 지시하기 때문이다. 만약 자전거에 쌀을 싣는다고 하면 이 지시는 합리적이지만 택배차가 트럭이라면 좀 에바다. 컴파일러라면 택배차가 쌀을 많이 실을 능력이 된다고 판단하면 '쌀을 많이 싣고 최대한 많은 집에 방문하면서 쌀을 배송한다. 쌀집으로 돌아온다.'라는, 최적화된 배송 계획을 짠다. 트럭이 두 대가 되도 컴파일러는 언제나 최적의 계획을 짜준다.
  - 만약, CPU / RAM이 작고 컴파일러보다 인간이 최적화를 더 잘 해야 하는 경우 어셈블리어가 유리하지만 CPU와 RAM이 조금만 확보되면 C, C++이 유리할 수 있다.

  > **Low Level 프로그래밍 언어**

  - 기계 친화적인 언어를 가리키는 데 쓰인다.
  - 액션스크립트 > 자바 > C > 어셈블리어 > 기계어 순으로 로우 레벨이다. 
  - 속도가 빠르고 여러 가지를 개발자가 직접 건드릴 수 있다. 근데 생산성이 낮고 어려움의 정도가 '조금'이 아니라 '많이' 어려운게 함정

## 직무 면접

### OS Deadlock이란?

- Deadlock 
  - 운영체제 혹은 소프트웨어의 잘못된 자원 관리로 둘 이상의 프로세스가 함께 멈추어 버리는 현상
  - **식사하는 철학자 문제**
    - 원탁에 철학자가 앉아서 식사를 하는데 철학자들 사이에 포크가 놓여져 있고 얘들은 양쪽 손에 포크를 들고 있어야 식사가 가능하다.
    - 근데 다들 동시에 왼쪽에 있는 포크를 집어들었는데, 오른쪽 포크를 집을 때까지 기다려야하는데 모든 철학자가 그러고 있으니 영원히 그 상태에 머물러있다. 요거시 데드락(Deadlock)
    - **해결 방법**
      - OS 차원의 해결법
        - 한 철학자가 포크를 집는다면, 반대쪽 포크를 잡을 때까지 행동권을 넘길 수 없게 하는 것
      - 하드웨어 아키텍쳐 차원의 해결법
        - 양쪽 포크를 동시에 잡게 하는 명령어를 사용하면 된다
      - 소프트웨어 차원의 해결법
        1. 타임아웃 설정
           - 철학자가 포크를 집고 일정 시간 내에 다른 쪽 포크를 획득하는데 실패하면, 포크를 반납한다.
        2. 포크 하나하나에 비교 가능한 고유 값을 부여하여, 고유 값이 높은 순서대로 포크를 집게 만든다.
      - *에츠허르 데이크스트라*의 해결책
        - 철학자를 P1 ~ P5라고 하고 철학자의 왼쪽 포크를 f1 ~ f5라고 하자. P5를 제외한 네 명은 fn을 집고 fn+1를 집는 방식을 취하고, P5는 이와 반대로 f1을 먼저 집고 f5를 집는다.
        - 이렇게 하면 방식의 대칭성을 제거하고 교착 상태를 막을 수 있다.
  - 시스템 파일이나 다른 프로그램이 공유하는 파일을 건드리기 쉬운 프로그램 설치 과정중에 "프로그램을 설치할 때는 가능하면 다른 프로그램은 모두 꺼 주세요"라는 말이 나오는 이유가 이 놈 때문
  - **발생 조건**
    1. 상호 배제
       - 자원 자체를 동시에 쓸 수 없는 경우
    2. 점유 상태로 대기
       - 자원을 붙잡은 상태에서 다른 자원을 기다리는 행위
       - Skype가 마이크와 카메라를 써야 하는데 마이크는 땡겨오는데 성공했지만 카메라 앱이 카메라를 잡고 있어서 그걸 기다리고 있고, 이 때문에 불쌍한 녹음기가 마이크를 사용하지 못한다.
    3. 선점 불가
       - 다른 프로세스가 자원을 뺏어올 방법이 없다.
       - 녹음기가 Skype의 마이크를 강제로 뺏어올 수 없고 Skype가 카메라를 강제로 뺏어올 수 없는 경우
    4. 순환성 대기
       - 대기가 꼬리를 물고 사이클이 된 상황

### DB Transaction

- Database transaction
  - transaction이라 함은 한꺼번에 수행되어야할 일련의 연산이다.
  - 모든 연산은 반드시 한꺼번에 완료가 되어야 하며, 그렇지 않으면 한꺼번에 취소가되어야 한다.
  - 한꺼번에 완료가 됐으면 Commit / 그게 아니면 Rollback(이 경우 작업결과는 모두 취소)
  - transaction의 특징 4가지
    1. 원자성
       - transaction이 데이터베이스에 모두 반영이되던가, 모두 반영이 되지 않아야 한다. 만약, transaction 단위로 데이터가 처리되지 않으면, 오작동이 일어날 수 있다.
    2. 일관성
       - transaction의 작업 처리 결과가 항상 일관성이 있어야 한다. transaction이 진행되는 동안엔 데이터베이스가 변경 되더라도 transaction은 업데이트된 데이터베이스를 참조하지 않고, 처음 참조했던 순간의 데이터베이스를 참조한다. 즉, 일관성 있는 데이터를 볼 수 있다.
    3. 독립성
       - 둘 이상의 transaction이 동시에 병행 실행되고 있을 경우 어느 하나의 transaction도 다른 transaction의 연산을 끼어들 수 없다.
    4. 지속성
       - transaction이 성공적으로 완료됐을 경우, 결과는 영구적으로 반영되어야 한다.
  - Commit
    - 하나의 transaction이 성공적으로 끝났고, 데이터베이스가 일관성있는 상태에 있을 때, 하나의 transaction이 끝났다라는 것을 알려주기위해 사용하는 연산
  - Rollback
    - 하나의 transaction 처리가 비정상적으로 종료되어 원자성이 깨진경우, 연산된 결과를 다시 취소시킨다.
  - Example
    - 인출 상황
      1. 카드를 넣는다.
      2. 어떤 거래를 할 지 선택하고
      3. 비밀번호를 눌러 인증을 받고
      4. 거래를 완료
    - 위 4가지를 묶어서 Transaction이라고 한다.
    - 거래가 완료되면 그 상태를 COMMIT
    - 중간에 비번이 틀리거나, 인증을 받았는데 거래를 취소하여 처음으로 돌아가면 ROLLBACK이라고 한다.

### Quick Sort 알고리즘

- 퀵 정렬

  - 불안정 정렬에 속하고, 비교 정렬에 속한다.

  - 분할 정복 알고리즘을 적용한 정렬 알고리즘이다.

  - 보통은 O(nlogn)이다. 최악의 경우 시간복잡도가 O(n^2)인데, 피벗을 최솟값이나 최댓값으로 계속해서 잡게 되는 경우이다.

  - 과정

    1. 리스트 가운데서 하나의 원소를 고른다. (**피벗**)
    2. 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 리스트를 둘로 나눈다. (**분할**) 분할이 마치면 피벗은 더 이상 움직이지 않는다.
    3. 재귀적으로 이 과정을 반복한다.

  - 예시

    5 - 3 - 7 - 6 - 2 - 1 - 4

    i			    j    p

    1. i 위치의 값이 피벗 값보다 크고, 오른쪽에 있는 j 위치의 값은 피벗 값보다 작으므로 둘을 교환한다.

    1 - 3 - 7 - 6 - 2 - 5 - 4

    i			    j    p

    2. j 위치의 값이 피벗 값보다 작지만, i 위치의 값도 피벗값보다 작으므로 교환하지 않는다.

    1 - 3 - 7 - 6 - 2 - 5 - 4

    ​      i		      j         p

    3. i위치를 피벗 값보다 큰 값이 나올 때까지 진행해서 j 위치의 값과 교환한다.

    1 - 3 - 7 - 6 - 2 - 5 - 4

    ​	   i	      j  	 p

    1 - 3 - 2 - 6 - 7 - 5 - 4

    ​	   i	      j  	 p

    4. i위치가 j 위치보다 커지거나 같으면, i 위치의 값과 피벗 값을 교환한다.

    1 - 3 - 7 - 6 - 2 - 5 - 4

    ​	         ij      	 p

    1 - 3 - 7 - 4 - 2 - 5 - 6

    5. 피벗 값 좌우의 리스트에 대해 각각 퀵 정렬을 재귀적으로 수행한다.

    1 - 3 - 2   //  7 - 5 - 6

### HTTP Method Get vs Post

- 둘의 차이는 단순히 Read와 Create라고 말할 수 있지만
- 추가적으로 Idempotent라는 특징이 있다. Idempotent는 멱등의라고 하는데 f(x) = f(f(x))로 생각하면 편하다.
- 다시 말해 몇 번이고 같은 연산을 반복해도 같은 값이 나온다는 것이다.
- GET은 몇 번이고 반복해도 같은 값이 나오지만 POST는 idempotent하지 않다.

- 예를 들어 유저가 어떤 요청을 했는데 어떤 이유로 요청이 끊겼다고 가정하는데, 만약 클라이언트가 원하는 operation이 idempotent하다면 다시 요청해도 상관 없다.

  > **클라이언트란?**

  - Client - Server 구성에서 사용자가 서버에 접속하기 위해 사용하는 프로그램 또는 서비스
  - 흔히 접할 수 있는 예시로는 게임 클라이언트가 있다. 특정 네트워크에 적속하는 거의 모든 프로그램 전부를 클라이언트라고 볼 수 있다.

### 객체 지향 프로그래밍 (OOP)

- 객체 지향 프로그래밍은 procedual programming(절차 지향 프로그래밍)의 상위 개념이다. 반대 개념이 아니다. (함수를 이용하여 프로그래밍을 만든다)

- 정보가 하나가 있으면 간단하지만, 정보가 양이 많아질 수록 기록할 필요성을 느낀다. 그래도 더 많아지면 그룹핑을 해야할 것이다. 즉, 어떤 것의 양이 늘어나면 완전히 다른 관리 체계가 필요하다.

- 또, 다른 예로는 장난감들이 방에 널부러져 있으면, 스트레스를 받는다. 그래서 우리는 수납 상자를 사서 거기에 장난감들을 넣고 상자에 이름을 붙일 수 있다. Toy라고, 그러면 그 안에 있는 장난감을 신경 쓸 필요없이 상자만 관리하면된다. 복잡성이 줄어들었다.

- 코드로 비유를 하면, 코드의 양이 늘어나면서 서로의 간섭도가 증가하고, 복잡도가 증가한다. 그렇기에 이걸 그룹핑하는 것이 중요하다.

- 어떤 매우 매우 복잡한 코드를 계속해서 써내려가기 어려우니까, 얘를 함수에 담는다. 그럼 우리는 함수의 이름만 신경쓰면 된다. (여기까지가 Toy라는 상자에 장난감을 담은거라고 생각하면 된다)

  - 근데, 함수를 통해서 복잡도를 낮춘건 사실이지만, 기술이 발전하면서 인간이 감당할 수 없는 정도로 복잡성이 증가해졌다. 그래서 좀 더 상위적인 내용이 필요했다.

- 이걸 해결하기 위해서 객체 지향 프로그래밍이 발전되었다. 서로 연관되어 있는 함수와 변수들을 객체라는 그룹핑했다. 그 객체에다가 이름을 toy라고 짓는다. 그러면 객체안에 있는 함수를 호출할 때 toy.do1() / toy.do2()로 사용할 수 있다.

  > **장점**

  - 코드 재사용이 용이
    - 남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있음.
  - 유지보수가 쉬움
    - 절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수혹은 메서드로 있기 때문에 해당 부분만 수정하면 됨.
  - 대형 프로젝트에 적합
    - 클래스단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러회사에서 개발이 필요할 시 업무 분담이 쉽다.

  > **단점**

  - 처리속도가 느림
  - 객체가 많으면 용량이 커질 수 있음
  - 설계시 많은 시간과 노력이 필요

- 객체 지향 프로그래밍 키워드 5가지

  - 클래스 + 인스턴스(객체)
    - 클래스 : 어떤 문제를 해결하기 위해 추상화를 거쳐 집단에 속하는 속성과 행위를 변수와 메서드로 정의한 것
    - 인스턴스(객체) : 클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것
  - 추상화
    - 객체지향 관점에서 클래스를 정의하는 것
    - 불필요한 정보는 숨기고 중요한 정보만을 표현
    - 공통의 속성이나 기능을 묶어 이름을 붙이는 것
  - 캡슐화
    - 목적 : 코드를 재수정 없이 재활용하는 것
    - 객체 지향 프로그래밍에서 기능과 특성의 모음을 "클래스"라는 "캡슐"에 분류해서 넣는것이 캡슐화이다.
    - 한 곳의 변화가 다른 곳에 미치는 영향을 최소화 해야한다.
  - 상속
    - 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것 (오버라이딩이라고도 한다)
  - 다형성

- 객체 지향적 설계 원칙

  1. SRP(Single Responsibility Principle) : 단일 책임 원칙
     - 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
  2. OCP(Open-Closed Principle) : 개방 - 폐쇄 원칙
     - 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
  3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
     - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
  4. ISP(Interface Segregation Principle): 인터페이스 분리 원칙
     - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
  5. DIP(Dependency Inversion Principle): 의존 역전 원칙
     - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

### 프로세스

- 사전적 의미
  - 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
  - 메모리에 올라와 실행되고 있는 프로그램의 인스턴스
  - 운영체제로부터 시스템 자원을 할당받는 작업의 단위 (할당받는 시스템 자원의 예 - CPU 시간 / 운영되기 위해 필요한 주소 공간)
  - 실행된 프로그램을 의미

- 특징
  - 프로세스는 각각 독립된 메모리 영역을 할당ㅂㄷ는다.
  - 기본적으로 프로세스당 최소 1개의 스레드를 가지고 있다.

### 스레드

- 사전적 의미
  - 프로세스 내에서 실행되는 여러 흐름의 단위
  - 프로세스의 특정한 수행 경로
  - 프로세스가 할당받은 자원을 이용하는 실행의 단위

- 최신 운영체제의 필수요소 중 하나 / 프로세스보다도 작은 실행 흐름의 최소 단위이다. 대다수의 OS가 스레드를 최소 단위로 하여 작동한다.
  - 예전에는 프로그램을 실행하는 흐름이 오로지 프로세스뿐이었으나, 소프트웨어가 진보하면서 하나의 프로그램에서 복잡한 동시 작업을 요구하기 시작했다. 이를 위해서 프로그램 하나에 여러개의 프로세스를 만들어야 했는데 프로세스 특성상 동시 작업을 수월하게 할 수 없었다.
  - 그래서 만들어지게 된게 더 작은 실행 단위 개념인 스레드이다.
  - 하나의 프로세스에서 여러개의 스레드가 메모리를 공유하여 작동할 수 있으며, 그래서 생성과 속도가 빠르고, 적은 메모리를 점유하며, 정보교환이 십다.

### 스레드와 프로세스의 차이점

- 프로세스 : 각각의 은행 지점
- 스레드 : 은행 지점 하나에 속한 고객 창구 여러 개
- 프로세스는 서로 완벽히 독립적인 공간을 갖는다. 각자가 각자의 데이터 영역을 가지고, 보호받는다. 한 프로세스가 비정상적으로 종료해도 다른 프로세스에는 영향이 거의 없다. 은행 지점 하나가 화재 등으로 손상되어도 다른 지점에서 업무를 볼 수 있는 것과 비슷하다.
- 스레드는 코드 영역과 데이터 영역은 하나를 공유한다. 같은 은행 지점에서는 옆 창구에 말만 하면 바로 알아들을 수 있는 것과 비슷하다. 단, 스레드 하나가 비정상 종료한다면 같은 프로세스에 소속된 다른 스레드들까지 모두 강제로 종료된다.

### MVC 아키텍쳐

- Django의 M T V와 똑같다.

  - Controller = Templates
    - 클라이언트의 요청을 받고 실제 업무를 수행하는 모델 컴포넌트를 호출한다. 그리고 데이터도 가공하고 업무를 마치면 그 결과를 뷰에게 전달한다.
  - Model
    - 컨트롤러가 호출할 때, 요청에 맞는 역할을 수행한다. DB에 연결되어 데이터를 추출하거나 저장, 삭제, 업데이트, 변환 등의 작업을 수행한다. 상태의 변화가 있을 땐 컨트롤러와 뷰에 통보하여 후속 조치 명령을 받을 수 있게한다.
  - View
    - 사용자에게 출력할 화면을 만드는 일을 한다. 만들어진 화면을 웹브라우저에 전송하여 웹브라우저가 출력하게 하는 것

- 나는 Django 기준으로 생각해야겠다.

  - View : 중간관리자x`
  - Model : 데이터 관리
  - WWTemplate : 사용자가 보는 화면

  1. 사용자가 요청을 한다.
  2. View가 요청을 받고 Model에게 data를 가져와달라고 한다.
  3. Model이 data를 찾고 View에게 건내준다.
  4. View는 그 data를 Template에게 넘긴다.
  5. 가공된 Template을 사용자에게 보낸다.

### 데이터베이스

- 특정한 방법으로 조직화된 데이터의 집합, 그 중 관계형 데이터베이스를 중점으로 얘기하겠다.

- 관계형 데이터 베이스는 행과 열로 구성된 2차원 테이블의 연결 개념이다. 사용자는 여러 테이블 사이의 관계를 그릴 수 있고 다시 테이블로 출력할 수 있다. 관계형 프로그래밍은 비절차형이다.

  > 절차형과 비절차형

  - 프로그래밍 언어가 조건문 같은 프로그래밍 요소를 사용하면 절차형이다.

  - SQL은 문장에 이러한 유형을 사용하지 않으며 비절차형의 예이다.

> **SQL**(Structured Query Language)

- SQL은 모든 데이터베이스의 질의에 사용되는 언어, 데이터베이스 응용 프로그램 설계의 핵심

- DBMS(Database management system, 데이터베이스를 저장 및 관리할 수 있는 기능을 제공하는 응용 프로그램)(오라클 데이터베이스, MySQL, SQLite가 대표적인 DBMS)에 따라서 SQL에 차이가 있다.